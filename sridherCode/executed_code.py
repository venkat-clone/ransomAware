# -*- coding: utf-8 -*-
"""executed_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pIloITimeVSn3S4UrTZUxQnqMyPkj4Co
"""

# !pip install pycryptodome
#
# !gdown --folder 1YuiuTxxWQjDS88-tBp4WyRA3sp5rrUW- -O /content

import re


def extract_between_markers(input_string, start_marker, end_marker):
    pattern = re.compile(f'{re.escape(start_marker)}\s*(.*?)\s*{re.escape(end_marker)}', re.DOTALL | re.IGNORECASE)
    match = pattern.search(input_string)

    if match:
        return match.group(1)
    else:
        return None

def save_base64_to_file(base64_content, output_file):
    with open(output_file, 'w', encoding='utf-8') as file:
        file.write(base64_content)

# Example Usage
file_path = "/content/ransomnote.txt"
start_marker = "---BEGIN MAZE KEY---"
end_marker = "---END MAZE KEY---"

try:
    with open(file_path, 'r', errors='replace') as file:
        input_text = file.read()
except FileNotFoundError:
    print(f"File not found: {file_path}")
    exit()

encoded_string = extract_between_markers(input_text, start_marker, end_marker)

if encoded_string:
    print("Encoded String:", encoded_string)

    output_file = "decoded_text.txt"
    save_base64_to_file(encoded_string, output_file)
    print(f"Decoded text saved to {output_file}")
else:
    print("Markers not found or order is incorrect.")

import sys
import base64
from backendApis import chacha


def rsa_construct_blob(blob):
    """Construct RSA key from BLOB"""
    is_private = False
    type_ver, key_alg, magic, key_bitlen = struct.unpack_from('<4L', blob, 0)

    if (type_ver == 0x207) and (key_alg == 0xA400) and (magic == 0x32415352):
        is_private = True
    elif (type_ver != 0x206) or (key_alg != 0xA400) or (magic != 0x31415352):
        raise ValueError('Invalid RSA blob')

    pos = 16
    key_len = math.ceil(key_bitlen / 8)

    e = int.from_bytes(blob[pos : pos + 4], byteorder='little')
    pos += 4
    n = int.from_bytes(blob[pos : pos + key_len], byteorder='little')

    if not is_private:
        return RSA.construct((n, e))

    key_len2 = math.ceil(key_bitlen / 16)

    pos += key_len
    p = int.from_bytes(blob[pos : pos + key_len2], byteorder='little')
    pos += key_len2
    q = int.from_bytes(blob[pos : pos + key_len2], byteorder='little')
    pos += key_len2
    dp = int.from_bytes(blob[pos : pos + key_len2], byteorder='little')
    pos += key_len2
    dq = int.from_bytes(blob[pos : pos + key_len2], byteorder='little')
    pos += key_len2
    iq = int.from_bytes(blob[pos : pos + key_len2], byteorder='little')
    pos += key_len2
    d = int.from_bytes(blob[pos : pos + key_len], byteorder='little')

    if (dp != d % (p - 1)) or (dq != d % (q - 1)):
        raise ValueError('Invalid RSA blob')

    return RSA.construct((n, e, d, p, q))

def decrypt_maze_key(filename='/content/decoded_text.txt'):
    RSA_KEY_SIZE = 256
    RSA_PRIV_KEY_BLOB_SIZE = 1172
    CHACHA_ROUNDS = 8
    SENTINEL_SIZE = 16

    with io.open(filename, 'rb') as f:
        data = base64.b64decode(f.read())

    for key_file_index in range(1, 40):
        key_file_path = f'/content/Keys/private_master{key_file_index}.bin'

        try:
            with io.open(key_file_path, 'rb') as key_file:
                master_key_blob = key_file.read()

            master_priv_key = rsa_construct_blob(master_key_blob)

            pos = RSA_PRIV_KEY_BLOB_SIZE
            enc_priv_key_blob = data[:pos]
            enc_chacha_key = data[pos : pos + RSA_KEY_SIZE]
            pos += RSA_KEY_SIZE
            enc_chacha_nonce = data[pos : pos + RSA_KEY_SIZE]
            pos += RSA_KEY_SIZE

            cipher = PKCS1_v1_5.new(master_priv_key)
            sentinel = os.urandom(SENTINEL_SIZE)
            chacha_key = cipher.decrypt(enc_chacha_key[::-1], sentinel)
            if chacha_key == sentinel:
                print(f'Failed to decrypt ChaCha20 key for key file {key_file_index}')
                continue

            sentinel = os.urandom(SENTINEL_SIZE)
            chacha_nonce = cipher.decrypt(enc_chacha_nonce[::-1], sentinel)
            if chacha_nonce == sentinel:
                print(f'Failed to decrypt ChaCha20 nonce for key file {key_file_index}')
                continue

            cipher = chacha.ChaCha(chacha_key, chacha_nonce, 0, CHACHA_ROUNDS)
            priv_key_blob = cipher.decrypt(enc_priv_key_blob)
            priv_key = rsa_construct_blob(priv_key_blob)

            print(f'ChaCha20 key size: {len(chacha_key)}')
            print(f'ChaCha20 nonce size: {len(chacha_nonce)}')
            print(f'Private RSA key size: {priv_key.size_in_bits()}')

            with io.open('private.bin', 'wb') as f:
                f.write(priv_key_blob)

            return priv_key

        except FileNotFoundError:
            print(f'Key file not found: {key_file_path}')
            continue

    print('Failed to decrypt with all key files')
    return None

# Example Usage in Colab
private_key = decrypt_maze_key('/content/decoded_text.txt')
if private_key:
    print(private_key)

import io
import os
import shutil
import math
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

# RSA
RSA_KEY_SIZE = 256

# ChaCha20/8
CHACHA_KEY_SIZE = 32
CHACHA_NONCE_SIZE = 8
CHACHA_ROUNDS = 8

# Metadata
ENC_MARKER = b'\x66\x11\x61\x66'

METADATA_SIZE = RSA_KEY_SIZE + 4 + len(ENC_MARKER)

BLOCK_SIZE = 0x10000

SENTINEL_SIZE = 16


def rsa_construct_blob(blob):
    """Construct RSA key from BLOB"""
    is_private = False

    type_ver, key_alg, magic, key_bitlen = struct.unpack_from('<4L', blob, 0)
    # "RSA2"
    if (type_ver == 0x207) and (key_alg == 0xA400) and (magic == 0x32415352):
        is_private = True
    # "RSA1"
    elif (type_ver != 0x206) or (key_alg != 0xA400) or (magic != 0x31415352):
        raise ValueError('Invalid RSA blob')

    pos = 16
    key_len = math.ceil(key_bitlen / 8)

    e = int.from_bytes(blob[pos: pos + 4], byteorder='little')
    pos += 4
    n = int.from_bytes(blob[pos: pos + key_len], byteorder='little')

    if not is_private:
        return RSA.construct((n, e))

    key_len2 = math.ceil(key_bitlen / 16)

    pos += key_len
    p = int.from_bytes(blob[pos: pos + key_len2], byteorder='little')
    pos += key_len2
    q = int.from_bytes(blob[pos: pos + key_len2], byteorder='little')
    pos += key_len2
    dp = int.from_bytes(blob[pos: pos + key_len2], byteorder='little')
    pos += key_len2
    dq = int.from_bytes(blob[pos: pos + key_len2], byteorder='little')
    pos += key_len2
    iq = int.from_bytes(blob[pos: pos + key_len2], byteorder='little')
    pos += key_len2
    d = int.from_bytes(blob[pos: pos + key_len], byteorder='little')

    if (dp != d % (p - 1)) or (dq != d % (q - 1)):
        raise ValueError('Invalid RSA blob')

    return RSA.construct((n, e, d, p, q))


def decrypt_file(filename, priv_key):
    """Decrypt file"""
    with io.open(filename, 'rb+') as f:
        # Read metadata
        try:
            f.seek(-METADATA_SIZE, 2)
        except OSError:
            return False

        metadata = f.read(METADATA_SIZE)

        # Check metadata marker
        if metadata[-len(ENC_MARKER):] != ENC_MARKER:
            return False

        # Decrypt ChaCha20 key and nonce
        cipher = PKCS1_v1_5.new(priv_key)

        sentinel = os.urandom(SENTINEL_SIZE)
        enc_key_data = metadata[:RSA_KEY_SIZE]
        key_data = cipher.decrypt(enc_key_data[::-1], sentinel)
        if key_data == sentinel:
            return False

        key = key_data[:CHACHA_KEY_SIZE]
        nonce = key_data[CHACHA_KEY_SIZE:
                         CHACHA_KEY_SIZE + CHACHA_NONCE_SIZE]

        # Remove metadata
        f.seek(-METADATA_SIZE, 2)
        f.truncate()

        cipher = chacha.ChaCha(key, nonce, 0, CHACHA_ROUNDS)

        f.seek(0)

        while True:
            enc_data = f.read(BLOCK_SIZE)
            if enc_data == b'':
                break

            data = cipher.decrypt(enc_data)

            f.seek(-len(enc_data), 1)
            f.write(data)

    return True


# Main

    # Use the first uploaded file
filename = '/content/php-8.2.5-src.zip.r2kKd'

# Read RSA private key BLOB
with io.open('/content/private.bin', 'rb') as f:
    priv_key_blob = f.read()

# Get RSA private key from BLOB
priv_key = rsa_construct_blob(priv_key_blob)
if (priv_key is None) or not priv_key.has_private():
    print('Error: Invalid RSA private key BLOB')
    sys.exit(1)

# Copy file
new_filename = filename + '.dec'
shutil.copy(filename, new_filename)

# Decrypt file
if not decrypt_file(new_filename, priv_key):
    os.remove(new_filename)
    print('Error: Failed to decrypt file')
    sys.exit(1)

print('File decrypted successfully:', new_filename)

import io
import os
import struct

# ChaCha20/8
CHACHA_KEY_SIZE = 32
CHACHA_NONCE_SIZE = 8
CHACHA_ROUNDS = 8

# Metadata
ENC_MARKER = b'\x66\x11\x61\x66'

METADATA_SIZE = CHACHA_KEY_SIZE + CHACHA_NONCE_SIZE + len(ENC_MARKER)

BLOCK_SIZE = 0x10000

SENTINEL_SIZE = 16

def read_chacha_key(file_path):
    """Read ChaCha20/8 key and nonce from file"""
    with open(file_path, 'rb') as f:
        key_nonce = f.read(CHACHA_KEY_SIZE + CHACHA_NONCE_SIZE)
    return key_nonce[:CHACHA_KEY_SIZE], key_nonce[CHACHA_KEY_SIZE:]

def encrypt_file(filename, key, nonce):
    """Encrypt file using ChaCha20/8"""
    cipher = chacha.ChaCha(key, nonce, 0, CHACHA_ROUNDS)

    with io.open(filename, 'rb') as f:
        plaintext = f.read()

    ciphertext = cipher.encrypt(plaintext)

    with io.open(filename + '.enc', 'wb') as f:
        f.write(ciphertext)

def decrypt_file(filename, key, nonce):
    """Decrypt file using ChaCha20/8"""
    cipher = chacha.ChaCha(key, nonce, 0, CHACHA_ROUNDS)

    with io.open(filename + '.enc', 'rb') as f:
        ciphertext = f.read()

    plaintext = cipher.decrypt(ciphertext)

    with io.open(filename + '.dec', 'wb') as f:
        f.write(plaintext)

# Usage
private_file_path = '/content/private.bin'

key, nonce = read_chacha_key(private_file_path)

# Encrypt file
filename_to_encrypt = '/content/checker.txt'
encrypt_file(filename_to_encrypt, key, nonce)

# Decrypt file
filename_to_decrypt = '/content/checker.txt'
decrypt_file(filename_to_decrypt, key, nonce)